/*! third party licenses: js/vendor.LICENSE.txt */
import{_ as h,am as A,an as T,ao as F,ap as L,l as a,d as M,aq as Y,ar as j,as as H,ae as q,at as I,au as _,av as z,aw as K,ax as Q}from"./mermaid.core-sVubBsni.chunk.mjs";import{G as O}from"./graph-Md1iY3od.chunk.mjs";import{l as U}from"./layout-BBxHCR0-.chunk.mjs";import{w as y}from"./json-C5QEBH6g.chunk.mjs";import"./modulepreload-polyfill-f2ognj_V.chunk.mjs";import"./emoji-picker-SoWZqoso.chunk.mjs";import"./NcNoteCard-CImn6F9p-B8JQbLi8.chunk.mjs";import"./vue.runtime.esm-DaLNuXGQ.chunk.mjs";import"./_baseUniq-Bqp-Jnlg.chunk.mjs";import"./_basePickBy-g_PHrcNF.chunk.mjs";import"./clone-D1JKt5l0.chunk.mjs";var c=new Map,E=new Map,k=new Map,V=h(()=>{E.clear(),k.clear(),c.clear()},"clear"),S=h((r,n)=>{const e=E.get(n)||[];return a.trace("In isDescendant",n," ",r," = ",e.includes(r)),e.includes(r)},"isDescendant"),W=h((r,n)=>{const e=E.get(n)||[];return a.info("Descendants of ",n," is ",e),a.info("Edge is ",r),r.v===n||r.w===n?!1:e?e.includes(r.v)||S(r.v,n)||S(r.w,n)||e.includes(r.w):(a.debug("Tilt, ",n,",not in descendants"),!1)},"edgeInCluster"),G=h((r,n,e,s)=>{a.warn("Copying children of ",r,"root",s,"data",n.node(r),s);const g=n.children(r)||[];r!==s&&g.push(r),a.warn("Copying (nodes) clusterId",r,"nodes",g),g.forEach(d=>{if(n.children(d).length>0)G(d,n,e,s);else{const i=n.node(d);a.info("cp ",d," to ",s," with parent ",r),e.setNode(d,i),s!==n.parent(d)&&(a.warn("Setting parent",d,n.parent(d)),e.setParent(d,n.parent(d))),r!==s&&d!==r?(a.debug("Setting parent",d,r),e.setParent(d,r)):(a.info("In copy ",r,"root",s,"data",n.node(r),s),a.debug("Not Setting parent for node=",d,"cluster!==rootId",r!==s,"node!==clusterId",d!==r));const o=n.edges(d);a.debug("Copying Edges",o),o.forEach(f=>{a.info("Edge",f);const u=n.edge(f.v,f.w,f.name);a.info("Edge data",u,s);try{W(f,s)?(a.info("Copying as ",f.v,f.w,u,f.name),e.setEdge(f.v,f.w,u,f.name),a.info("newGraph edges ",e.edges(),e.edge(e.edges()[0]))):a.info("Skipping copy of edge ",f.v,"-->",f.w," rootId: ",s," clusterId:",r)}catch(m){a.error(m)}})}a.debug("Removing node",d),n.removeNode(d)})},"copy"),B=h((r,n)=>{const e=n.children(r);let s=[...e];for(const g of e)k.set(g,r),s=[...s,...B(g,n)];return s},"extractDescendants"),Z=h((r,n,e)=>{const s=r.edges().filter(o=>o.v===n||o.w===n),g=r.edges().filter(o=>o.v===e||o.w===e),d=s.map(o=>({v:o.v===n?e:o.v,w:o.w===n?n:o.w})),i=g.map(o=>({v:o.v,w:o.w}));return d.filter(o=>i.some(f=>o.v===f.v&&o.w===f.w))},"findCommonEdges"),b=h((r,n,e)=>{const s=n.children(r);if(a.trace("Searching children of id ",r,s),s.length<1)return r;let g;for(const d of s){const i=b(d,n,e),o=Z(n,e,i);if(i)if(o.length>0)g=i;else return i}return g},"findNonClusterChild"),C=h(r=>!c.has(r)||!c.get(r).externalConnections?r:c.has(r)?c.get(r).id:r,"getAnchorId"),$=h((r,n)=>{if(!r||n>10){a.debug("Opting out, no graph ");return}else a.debug("Opting in, graph ");r.nodes().forEach(function(e){r.children(e).length>0&&(a.warn("Cluster identified",e," Replacement id in edges: ",b(e,r,e)),E.set(e,B(e,r)),c.set(e,{id:b(e,r,e),clusterData:r.node(e)}))}),r.nodes().forEach(function(e){const s=r.children(e),g=r.edges();s.length>0?(a.debug("Cluster identified",e,E),g.forEach(d=>{const i=S(d.v,e),o=S(d.w,e);i^o&&(a.warn("Edge: ",d," leaves cluster ",e),a.warn("Descendants of XXX ",e,": ",E.get(e)),c.get(e).externalConnections=!0)})):a.debug("Not a cluster ",e,E)});for(let e of c.keys()){const s=c.get(e).id,g=r.parent(s);g!==e&&c.has(g)&&!c.get(g).externalConnections&&(c.get(e).id=g)}r.edges().forEach(function(e){const s=r.edge(e);a.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),a.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(r.edge(e)));let g=e.v,d=e.w;if(a.warn("Fix XXX",c,"ids:",e.v,e.w,"Translating: ",c.get(e.v)," --- ",c.get(e.w)),c.get(e.v)&&c.get(e.w)&&c.get(e.v)===c.get(e.w)){a.warn("Fixing and trying link to self - removing XXX",e.v,e.w,e.name),a.warn("Fixing and trying - removing XXX",e.v,e.w,e.name),g=C(e.v),d=C(e.w),r.removeEdge(e.v,e.w,e.name);const i=e.w+"---"+e.v+"---1",o=e.w+"---"+e.v+"---2";r.setNode(i,{domId:i,id:i,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),r.setNode(o,{domId:o,id:o,labelStyle:"",padding:0,shape:"labelRect",style:"",width:10,height:10});const f=structuredClone(s),u=structuredClone(s),m=structuredClone(s);f.label="",f.arrowTypeEnd="none",f.id=e.name+"-cyclic-special-1",u.arrowTypeEnd="none",u.id=e.name+"-cyclic-special-mid",m.label="",f.fromCluster=e.v,m.toCluster=e.v,m.id=e.name+"-cyclic-special-2",r.setEdge(g,i,f,e.name+"-cyclic-special-0"),r.setEdge(i,o,u,e.name+"-cyclic-special-1"),r.setEdge(o,d,m,e.name+"-cyclic-special-2")}else if(c.get(e.v)||c.get(e.w)){if(a.warn("Fixing and trying - removing XXX",e.v,e.w,e.name),g=C(e.v),d=C(e.w),r.removeEdge(e.v,e.w,e.name),g!==e.v){const i=r.parent(g);c.get(i).externalConnections=!0,s.fromCluster=e.v}if(d!==e.w){const i=r.parent(d);c.get(i).externalConnections=!0,s.toCluster=e.w}a.warn("Fix Replacing with XXX",g,d,e.name),r.setEdge(g,d,s,e.name)}}),a.warn("Adjusted Graph",y(r)),J(r,0),a.trace(c)},"adjustClustersAndEdges"),J=h((r,n)=>{var g,d;if(a.warn("extractor - ",n,y(r),r.children("D")),n>10){a.error("Bailing out");return}let e=r.nodes(),s=!1;for(const i of e){const o=r.children(i);s=s||o.length>0}if(!s){a.debug("Done, no node has children",r.nodes());return}a.debug("Nodes = ",e,n);for(const i of e)if(a.debug("Extracting node",i,c,c.has(i)&&!c.get(i).externalConnections,!r.parent(i),r.node(i),r.children("D")," Depth ",n),!c.has(i))a.debug("Not a cluster",i,n);else if(!c.get(i).externalConnections&&r.children(i)&&r.children(i).length>0){a.warn("Cluster without external connections, without a parent and with children",i,n);let o=r.graph().rankdir==="TB"?"LR":"TB";(d=(g=c.get(i))==null?void 0:g.clusterData)!=null&&d.dir&&(o=c.get(i).clusterData.dir,a.warn("Fixing dir",c.get(i).clusterData.dir,o));const f=new O({multigraph:!0,compound:!0}).setGraph({rankdir:o,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});a.warn("Old graph before copy",y(r)),G(i,r,f,i),r.setNode(i,{clusterNode:!0,id:i,clusterData:c.get(i).clusterData,label:c.get(i).label,graph:f}),a.warn("New graph after copy node: (",i,")",y(f)),a.debug("Old graph after copy",y(r))}else a.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!c.get(i).externalConnections," no parent: ",!r.parent(i)," children ",r.children(i)&&r.children(i).length>0,r.children("D"),n),a.debug(c);e=r.nodes(),a.warn("New list of nodes",e);for(const i of e){const o=r.node(i);a.warn(" Now next level",i,o),o.clusterNode&&J(o.graph,n+1)}},"extractor"),P=h((r,n)=>{if(n.length===0)return[];let e=Object.assign([],n);return n.forEach(s=>{const g=r.children(s),d=P(r,g);e=[...e,...d]}),e},"sorter"),ee=h(r=>P(r,r.children()),"sortNodesByHierarchy"),R=h(async(r,n,e,s,g,d)=>{a.info("Graph in recursive render: XXX",y(n),g);const i=n.graph().rankdir;a.trace("Dir in recursive render - dir:",i);const o=r.insert("g").attr("class","root");n.nodes()?a.info("Recursive render XXX",n.nodes()):a.info("No nodes found for",n),n.edges().length>0&&a.info("Recursive edges",n.edge(n.edges()[0]));const f=o.insert("g").attr("class","clusters"),u=o.insert("g").attr("class","edgePaths"),m=o.insert("g").attr("class","edgeLabels"),p=o.insert("g").attr("class","nodes");await Promise.all(n.nodes().map(async function(l){const t=n.node(l);if(g!==void 0){const w=JSON.parse(JSON.stringify(g.clusterData));a.trace("Setting data for parent cluster XXX\n Node.id = ",l,"\n data=",w.height,"\nParent cluster",g.height),n.setNode(g.id,w),n.parent(l)||(a.trace("Setting parent",l,g.id),n.setParent(l,g.id,w))}if(a.info("(Insert) Node XXX"+l+": "+JSON.stringify(n.node(l))),t==null?void 0:t.clusterNode){a.info("Cluster identified XBX",l,t.width,n.node(l));const{ranksep:w,nodesep:v}=n.graph();t.graph.setGraph({...t.graph.graph(),ranksep:w+25,nodesep:v});const X=await R(p,t.graph,e,s,n.node(l),d),N=X.elem;Y(t,N),t.diff=X.diff||0,a.info("New compound node after recursive render XAX",l,"width",t.width,"height",t.height),j(N,t)}else n.children(l).length>0?(a.info("Cluster - the non recursive path XBX",l,t.id,t,t.width,"Graph:",n),a.info(b(t.id,n)),c.set(t.id,{id:b(t.id,n),node:t})):(a.trace("Node - the non recursive path XAX",l,t.id,t),await H(p,n.node(l),i))})),await h(async()=>{const l=n.edges().map(async function(t){const w=n.edge(t.v,t.w,t.name);a.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),a.info("Edge "+t.v+" -> "+t.w+": ",t," ",JSON.stringify(n.edge(t))),a.info("Fix",c,"ids:",t.v,t.w,"Translating: ",c.get(t.v),c.get(t.w)),await Q(m,w)});await Promise.all(l)},"processEdges")(),a.info("Graph before layout:",JSON.stringify(y(n))),a.info("############################################# XXX"),a.info("###                Layout                 ### XXX"),a.info("############################################# XXX"),U(n),a.info("Graph after layout:",JSON.stringify(y(n)));let D=0,{subGraphTitleTotalMargin:x}=q(d);return await Promise.all(ee(n).map(async function(l){var w;const t=n.node(l);if(a.info("Position XBX => "+l+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),t==null?void 0:t.clusterNode)t.y+=x,a.info("A tainted cluster node XBX1",l,t.id,t.width,t.height,t.x,t.y,n.parent(l)),c.get(t.id).node=t,I(t);else if(n.children(l).length>0){a.info("A pure cluster node XBX1",l,t.id,t.x,t.y,t.width,t.height,n.parent(l)),t.height+=x,n.node(t.parentId);const v=(t==null?void 0:t.padding)/2||0,X=((w=t==null?void 0:t.labelBBox)==null?void 0:w.height)||0,N=X-v||0;a.debug("OffsetY",N,"labelHeight",X,"halfPadding",v),await _(f,t),c.get(t.id).node=t}else{const v=n.node(t.parentId);t.y+=x/2,a.info("A regular node XBX1 - using the padding",t.id,"parent",t.parentId,t.width,t.height,t.x,t.y,"offsetY",t.offsetY,"parent",v,v==null?void 0:v.offsetY,t),I(t)}})),n.edges().forEach(function(l){const t=n.edge(l);a.info("Edge "+l.v+" -> "+l.w+": "+JSON.stringify(t),t),t.points.forEach(N=>N.y+=x/2);const w=n.node(l.v);var v=n.node(l.w);const X=z(u,t,c,e,w,v,s);K(t,X)}),n.nodes().forEach(function(l){const t=n.node(l);a.info(l,t.type,t.diff),t.isGroup&&(D=t.diff)}),a.warn("Returning from recursive render XAX",o,D),{elem:o,diff:D}},"recursiveRender"),fe=h(async(r,n)=>{var d,i,o,f,u,m;const e=new O({multigraph:!0,compound:!0}).setGraph({rankdir:r.direction,nodesep:((d=r.config)==null?void 0:d.nodeSpacing)||((o=(i=r.config)==null?void 0:i.flowchart)==null?void 0:o.nodeSpacing)||r.nodeSpacing,ranksep:((f=r.config)==null?void 0:f.rankSpacing)||((m=(u=r.config)==null?void 0:u.flowchart)==null?void 0:m.rankSpacing)||r.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),s=n.select("g");A(s,r.markers,r.type,r.diagramId),T(),F(),L(),V(),r.nodes.forEach(p=>{e.setNode(p.id,{...p}),p.parentId&&e.setParent(p.id,p.parentId)}),a.debug("Edges:",r.edges),r.edges.forEach(p=>{e.setEdge(p.start,p.end,{...p},p.id)}),a.warn("Graph at first:",JSON.stringify(y(e))),$(e),a.warn("Graph after:",JSON.stringify(y(e)));const g=M();await R(s,e,r.type,r.diagramId,void 0,g)},"render");export{fe as render};
