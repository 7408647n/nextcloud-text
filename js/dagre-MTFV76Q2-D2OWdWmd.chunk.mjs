/*! third party licenses: js/vendor.LICENSE.txt */
import{_ as m,am as R,an as T,ao as F,ap as L,l as a,d as M,aq as Y,ar as j,as as H,ae as q,at as I,au as _,av as z,aw as K,ax as Q}from"./mermaid.core-0kqJzeij.chunk.mjs";import{G as O}from"./graph-CNHk7XeV.chunk.mjs";import{l as U}from"./layout-Cb4XOrj9.chunk.mjs";import{w as X}from"./json-v_2RcB6K.chunk.mjs";import"./modulepreload-polyfill-DMTabKmO.chunk.mjs";import"./emoji-picker-SoWZqoso.chunk.mjs";import"./NcNoteCard-CImn6F9p-9zf-u00P.chunk.mjs";import"./vue.runtime.esm-DaLNuXGQ.chunk.mjs";import"./_baseUniq-h5A9VGTV.chunk.mjs";import"./_basePickBy-C8MYhUMS.chunk.mjs";import"./clone-DAF9r9hI.chunk.mjs";var l=new Map,N=new Map,G=new Map,V=m(()=>{N.clear(),G.clear(),l.clear()},"clear"),S=m((e,r)=>{const n=N.get(r)||[];return a.trace("In isDescendant",r," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),W=m((e,r)=>{const n=N.get(r)||[];return a.info("Descendants of ",r," is ",n),a.info("Edge is ",e),e.v===r||e.w===r?!1:n?n.includes(e.v)||S(e.v,r)||S(e.w,r)||n.includes(e.w):(a.debug("Tilt, ",r,",not in descendants"),!1)},"edgeInCluster"),k=m((e,r,n,s)=>{a.warn("Copying children of ",e,"root",s,"data",r.node(e),s);const g=r.children(e)||[];e!==s&&g.push(e),a.warn("Copying (nodes) clusterId",e,"nodes",g),g.forEach(o=>{if(r.children(o).length>0)k(o,r,n,s);else{const i=r.node(o);a.info("cp ",o," to ",s," with parent ",e),n.setNode(o,i),s!==r.parent(o)&&(a.warn("Setting parent",o,r.parent(o)),n.setParent(o,r.parent(o))),e!==s&&o!==e?(a.debug("Setting parent",o,e),n.setParent(o,e)):(a.info("In copy ",e,"root",s,"data",r.node(e),s),a.debug("Not Setting parent for node=",o,"cluster!==rootId",e!==s,"node!==clusterId",o!==e));const d=r.edges(o);a.debug("Copying Edges",d),d.forEach(p=>{a.info("Edge",p);const E=r.edge(p.v,p.w,p.name);a.info("Edge data",E,s);try{W(p,s)?(a.info("Copying as ",p.v,p.w,E,p.name),n.setEdge(p.v,p.w,E,p.name),a.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):a.info("Skipping copy of edge ",p.v,"-->",p.w," rootId: ",s," clusterId:",e)}catch(b){a.error(b)}})}a.debug("Removing node",o),r.removeNode(o)})},"copy"),P=m((e,r)=>{const n=r.children(e);let s=[...n];for(const g of n)G.set(g,e),s=[...s,...P(g,r)];return s},"extractDescendants"),Z=m((e,r,n)=>{const s=e.edges().filter(d=>d.v===r||d.w===r),g=e.edges().filter(d=>d.v===n||d.w===n),o=s.map(d=>({v:d.v===r?n:d.v,w:d.w===r?r:d.w})),i=g.map(d=>({v:d.v,w:d.w}));return o.filter(d=>i.some(p=>d.v===p.v&&d.w===p.w))},"findCommonEdges"),x=m((e,r,n)=>{const s=r.children(e);if(a.trace("Searching children of id ",e,s),s.length<1)return e;let g;for(const o of s){const i=x(o,r,n),d=Z(r,n,i);if(i)if(d.length>0)g=i;else return i}return g},"findNonClusterChild"),D=m(e=>!l.has(e)||!l.get(e).externalConnections?e:l.has(e)?l.get(e).id:e,"getAnchorId"),$=m((e,r)=>{if(!e||r>10){a.debug("Opting out, no graph ");return}else a.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(a.warn("Cluster identified",n," Replacement id in edges: ",x(n,e,n)),N.set(n,P(n,e)),l.set(n,{id:x(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const s=e.children(n),g=e.edges();s.length>0?(a.debug("Cluster identified",n,N),g.forEach(o=>{const i=S(o.v,n),d=S(o.w,n);i^d&&(a.warn("Edge: ",o," leaves cluster ",n),a.warn("Descendants of XXX ",n,": ",N.get(n)),l.get(n).externalConnections=!0)})):a.debug("Not a cluster ",n,N)});for(let n of l.keys()){const s=l.get(n).id,g=e.parent(s);g!==n&&l.has(g)&&!l.get(g).externalConnections&&(l.get(n).id=g)}e.edges().forEach(function(n){const s=e.edge(n);a.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),a.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let g=n.v,o=n.w;if(a.warn("Fix XXX",l,"ids:",n.v,n.w,"Translating: ",l.get(n.v)," --- ",l.get(n.w)),l.get(n.v)||l.get(n.w)){if(a.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),g=D(n.v),o=D(n.w),e.removeEdge(n.v,n.w,n.name),g!==n.v){const i=e.parent(g);l.get(i).externalConnections=!0,s.fromCluster=n.v}if(o!==n.w){const i=e.parent(o);l.get(i).externalConnections=!0,s.toCluster=n.w}a.warn("Fix Replacing with XXX",g,o,n.name),e.setEdge(g,o,s,n.name)}}),a.warn("Adjusted Graph",X(e)),B(e,0),a.trace(l)},"adjustClustersAndEdges"),B=m((e,r)=>{var g,o;if(a.warn("extractor - ",r,X(e),e.children("D")),r>10){a.error("Bailing out");return}let n=e.nodes(),s=!1;for(const i of n){const d=e.children(i);s=s||d.length>0}if(!s){a.debug("Done, no node has children",e.nodes());return}a.debug("Nodes = ",n,r);for(const i of n)if(a.debug("Extracting node",i,l,l.has(i)&&!l.get(i).externalConnections,!e.parent(i),e.node(i),e.children("D")," Depth ",r),!l.has(i))a.debug("Not a cluster",i,r);else if(!l.get(i).externalConnections&&e.children(i)&&e.children(i).length>0){a.warn("Cluster without external connections, without a parent and with children",i,r);let d=e.graph().rankdir==="TB"?"LR":"TB";(o=(g=l.get(i))==null?void 0:g.clusterData)!=null&&o.dir&&(d=l.get(i).clusterData.dir,a.warn("Fixing dir",l.get(i).clusterData.dir,d));const p=new O({multigraph:!0,compound:!0}).setGraph({rankdir:d,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});a.warn("Old graph before copy",X(e)),k(i,e,p,i),e.setNode(i,{clusterNode:!0,id:i,clusterData:l.get(i).clusterData,label:l.get(i).label,graph:p}),a.warn("New graph after copy node: (",i,")",X(p)),a.debug("Old graph after copy",X(e))}else a.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!l.get(i).externalConnections," no parent: ",!e.parent(i)," children ",e.children(i)&&e.children(i).length>0,e.children("D"),r),a.debug(l);n=e.nodes(),a.warn("New list of nodes",n);for(const i of n){const d=e.node(i);a.warn(" Now next level",i,d),d!=null&&d.clusterNode&&B(d.graph,r+1)}},"extractor"),J=m((e,r)=>{if(r.length===0)return[];let n=Object.assign([],r);return r.forEach(s=>{const g=e.children(s),o=J(e,g);n=[...n,...o]}),n},"sorter"),ee=m(e=>J(e,e.children()),"sortNodesByHierarchy"),A=m(async(e,r,n,s,g,o)=>{a.warn("Graph in recursive render:XAX",X(r),g);const i=r.graph().rankdir;a.trace("Dir in recursive render - dir:",i);const d=e.insert("g").attr("class","root");r.nodes()?a.info("Recursive render XXX",r.nodes()):a.info("No nodes found for",r),r.edges().length>0&&a.info("Recursive edges",r.edge(r.edges()[0]));const p=d.insert("g").attr("class","clusters"),E=d.insert("g").attr("class","edgePaths"),b=d.insert("g").attr("class","edgeLabels"),h=d.insert("g").attr("class","nodes");await Promise.all(r.nodes().map(async function(c){const t=r.node(c);if(g!==void 0){const f=JSON.parse(JSON.stringify(g.clusterData));a.trace("Setting data for parent cluster XXX\n Node.id = ",c,"\n data=",f.height,"\nParent cluster",g.height),r.setNode(g.id,f),r.parent(c)||(a.trace("Setting parent",c,g.id),r.setParent(c,g.id,f))}if(a.info("(Insert) Node XXX"+c+": "+JSON.stringify(r.node(c))),t==null?void 0:t.clusterNode){a.info("Cluster identified XBX",c,t.width,r.node(c));const{ranksep:f,nodesep:w}=r.graph();t.graph.setGraph({...t.graph.graph(),ranksep:f+25,nodesep:w});const y=await A(h,t.graph,n,s,r.node(c),o),C=y.elem;Y(t,C),t.diff=y.diff||0,a.info("New compound node after recursive render XAX",c,"width",t.width,"height",t.height),j(C,t)}else r.children(c).length>0?(a.trace("Cluster - the non recursive path XBX",c,t.id,t,t.width,"Graph:",r),a.trace(x(t.id,r)),l.set(t.id,{id:x(t.id,r),node:t})):(a.trace("Node - the non recursive path XAX",c,h,r.node(c),i),await H(h,r.node(c),i))})),await m(async()=>{const c=r.edges().map(async function(t){const f=r.edge(t.v,t.w,t.name);a.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),a.info("Edge "+t.v+" -> "+t.w+": ",t," ",JSON.stringify(r.edge(t))),a.info("Fix",l,"ids:",t.v,t.w,"Translating: ",l.get(t.v),l.get(t.w)),await Q(b,f)});await Promise.all(c)},"processEdges")(),a.info("Graph before layout:",JSON.stringify(X(r))),a.info("############################################# XXX"),a.info("###                Layout                 ### XXX"),a.info("############################################# XXX"),U(r),a.info("Graph after layout:",JSON.stringify(X(r)));let u=0,{subGraphTitleTotalMargin:v}=q(o);return await Promise.all(ee(r).map(async function(c){var f;const t=r.node(c);if(a.info("Position XBX => "+c+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),t==null?void 0:t.clusterNode)t.y+=v,a.info("A tainted cluster node XBX1",c,t.id,t.width,t.height,t.x,t.y,r.parent(c)),l.get(t.id).node=t,I(t);else if(r.children(c).length>0){a.info("A pure cluster node XBX1",c,t.id,t.x,t.y,t.width,t.height,r.parent(c)),t.height+=v,r.node(t.parentId);const w=(t==null?void 0:t.padding)/2||0,y=((f=t==null?void 0:t.labelBBox)==null?void 0:f.height)||0,C=y-w||0;a.debug("OffsetY",C,"labelHeight",y,"halfPadding",w),await _(p,t),l.get(t.id).node=t}else{const w=r.node(t.parentId);t.y+=v/2,a.info("A regular node XBX1 - using the padding",t.id,"parent",t.parentId,t.width,t.height,t.x,t.y,"offsetY",t.offsetY,"parent",w,w==null?void 0:w.offsetY,t),I(t)}})),r.edges().forEach(function(c){const t=r.edge(c);a.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(t),t),t.points.forEach(C=>C.y+=v/2);const f=r.node(c.v);var w=r.node(c.w);const y=z(E,t,l,n,f,w,s);K(t,y)}),r.nodes().forEach(function(c){const t=r.node(c);a.info(c,t.type,t.diff),t.isGroup&&(u=t.diff)}),a.warn("Returning from recursive render XAX",d,u),{elem:d,diff:u}},"recursiveRender"),pe=m(async(e,r)=>{var o,i,d,p,E,b;const n=new O({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((o=e.config)==null?void 0:o.nodeSpacing)||((d=(i=e.config)==null?void 0:i.flowchart)==null?void 0:d.nodeSpacing)||e.nodeSpacing,ranksep:((p=e.config)==null?void 0:p.rankSpacing)||((b=(E=e.config)==null?void 0:E.flowchart)==null?void 0:b.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),s=r.select("g");R(s,e.markers,e.type,e.diagramId),T(),F(),L(),V(),e.nodes.forEach(h=>{n.setNode(h.id,{...h}),h.parentId&&n.setParent(h.id,h.parentId)}),a.debug("Edges:",e.edges),e.edges.forEach(h=>{if(h.start===h.end){const u=h.start,v=u+"---"+u+"---1",c=u+"---"+u+"---2",t=n.node(u);n.setNode(v,{domId:v,id:v,parentId:t.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(v,t.parentId),n.setNode(c,{domId:c,id:c,parentId:t.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(c,t.parentId);const f=structuredClone(h),w=structuredClone(h),y=structuredClone(h);f.label="",f.arrowTypeEnd="none",f.id=u+"-cyclic-special-1",w.arrowTypeEnd="none",w.id=u+"-cyclic-special-mid",y.label="",t.isGroup&&(f.fromCluster=u,y.toCluster=u),y.id=u+"-cyclic-special-2",n.setEdge(u,v,f,u+"-cyclic-special-0"),n.setEdge(v,c,w,u+"-cyclic-special-1"),n.setEdge(c,u,y,u+"-cyc<lic-special-2")}else n.setEdge(h.start,h.end,{...h},h.id)}),a.warn("Graph at first:",JSON.stringify(X(n))),$(n),a.warn("Graph after XAX:",JSON.stringify(X(n)));const g=M();await A(s,n,e.type,e.diagramId,void 0,g)},"render");export{pe as render};
