/*! third party licenses: js/vendor.LICENSE.txt */
import{_ as m,ao as R,ap as T,aq as F,ar as L,l as i,d as M,as as Y,at as j,au as H,ac as q,av as I,aw as z,ax as _,ay as K,az as Q}from"./mermaid.core-DqdNzqxr.chunk.mjs";import{G as O}from"./graph-DZ37XKmc.chunk.mjs";import{l as U}from"./layout-B6JRZuYv.chunk.mjs";import{w as X}from"./json-DZqYDdnR.chunk.mjs";import"./modulepreload-polyfill-DMTabKmO.chunk.mjs";import"./emoji-picker-SoWZqoso.chunk.mjs";import"./NcNoteCard-CImn6F9p-ChK0-hvc.chunk.mjs";import"./vue.runtime.esm-DaLNuXGQ.chunk.mjs";import"./_baseUniq-D0rUJipT.chunk.mjs";import"./_basePickBy-Bti6ONX5.chunk.mjs";import"./clone-CittjnBs.chunk.mjs";var l=new Map,N=new Map,G=new Map,V=m(()=>{N.clear(),G.clear(),l.clear()},"clear"),S=m((e,r)=>{const n=N.get(r)||[];return i.trace("In isDescendant",r," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),W=m((e,r)=>{const n=N.get(r)||[];return i.info("Descendants of ",r," is ",n),i.info("Edge is ",e),e.v===r||e.w===r?!1:n?n.includes(e.v)||S(e.v,r)||S(e.w,r)||n.includes(e.w):(i.debug("Tilt, ",r,",not in descendants"),!1)},"edgeInCluster"),k=m((e,r,n,o)=>{i.warn("Copying children of ",e,"root",o,"data",r.node(e),o);const g=r.children(e)||[];e!==o&&g.push(e),i.warn("Copying (nodes) clusterId",e,"nodes",g),g.forEach(s=>{if(r.children(s).length>0)k(s,r,n,o);else{const a=r.node(s);i.info("cp ",s," to ",o," with parent ",e),n.setNode(s,a),o!==r.parent(s)&&(i.warn("Setting parent",s,r.parent(s)),n.setParent(s,r.parent(s))),e!==o&&s!==e?(i.debug("Setting parent",s,e),n.setParent(s,e)):(i.info("In copy ",e,"root",o,"data",r.node(e),o),i.debug("Not Setting parent for node=",s,"cluster!==rootId",e!==o,"node!==clusterId",s!==e));const d=r.edges(s);i.debug("Copying Edges",d),d.forEach(p=>{i.info("Edge",p);const E=r.edge(p.v,p.w,p.name);i.info("Edge data",E,o);try{W(p,o)?(i.info("Copying as ",p.v,p.w,E,p.name),n.setEdge(p.v,p.w,E,p.name),i.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):i.info("Skipping copy of edge ",p.v,"-->",p.w," rootId: ",o," clusterId:",e)}catch(b){i.error(b)}})}i.debug("Removing node",s),r.removeNode(s)})},"copy"),P=m((e,r)=>{const n=r.children(e);let o=[...n];for(const g of n)G.set(g,e),o=[...o,...P(g,r)];return o},"extractDescendants"),Z=m((e,r,n)=>{const o=e.edges().filter(d=>d.v===r||d.w===r),g=e.edges().filter(d=>d.v===n||d.w===n),s=o.map(d=>({v:d.v===r?n:d.v,w:d.w===r?r:d.w})),a=g.map(d=>({v:d.v,w:d.w}));return s.filter(d=>a.some(p=>d.v===p.v&&d.w===p.w))},"findCommonEdges"),x=m((e,r,n)=>{const o=r.children(e);if(i.trace("Searching children of id ",e,o),o.length<1)return e;let g;for(const s of o){const a=x(s,r,n),d=Z(r,n,a);if(a)if(d.length>0)g=a;else return a}return g},"findNonClusterChild"),D=m(e=>!l.has(e)||!l.get(e).externalConnections?e:l.has(e)?l.get(e).id:e,"getAnchorId"),$=m((e,r)=>{if(!e||r>10){i.debug("Opting out, no graph ");return}else i.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(i.warn("Cluster identified",n," Replacement id in edges: ",x(n,e,n)),N.set(n,P(n,e)),l.set(n,{id:x(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const o=e.children(n),g=e.edges();o.length>0?(i.debug("Cluster identified",n,N),g.forEach(s=>{const a=S(s.v,n),d=S(s.w,n);a^d&&(i.warn("Edge: ",s," leaves cluster ",n),i.warn("Descendants of XXX ",n,": ",N.get(n)),l.get(n).externalConnections=!0)})):i.debug("Not a cluster ",n,N)});for(let n of l.keys()){const o=l.get(n).id,g=e.parent(o);g!==n&&l.has(g)&&!l.get(g).externalConnections&&(l.get(n).id=g)}e.edges().forEach(function(n){const o=e.edge(n);i.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),i.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let g=n.v,s=n.w;if(i.warn("Fix XXX",l,"ids:",n.v,n.w,"Translating: ",l.get(n.v)," --- ",l.get(n.w)),l.get(n.v)||l.get(n.w)){if(i.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),g=D(n.v),s=D(n.w),e.removeEdge(n.v,n.w,n.name),g!==n.v){const a=e.parent(g);l.get(a).externalConnections=!0,o.fromCluster=n.v}if(s!==n.w){const a=e.parent(s);l.get(a).externalConnections=!0,o.toCluster=n.w}i.warn("Fix Replacing with XXX",g,s,n.name),e.setEdge(g,s,o,n.name)}}),i.warn("Adjusted Graph",X(e)),B(e,0),i.trace(l)},"adjustClustersAndEdges"),B=m((e,r)=>{var g,s;if(i.warn("extractor - ",r,X(e),e.children("D")),r>10){i.error("Bailing out");return}let n=e.nodes(),o=!1;for(const a of n){const d=e.children(a);o=o||d.length>0}if(!o){i.debug("Done, no node has children",e.nodes());return}i.debug("Nodes = ",n,r);for(const a of n)if(i.debug("Extracting node",a,l,l.has(a)&&!l.get(a).externalConnections,!e.parent(a),e.node(a),e.children("D")," Depth ",r),!l.has(a))i.debug("Not a cluster",a,r);else if(!l.get(a).externalConnections&&e.children(a)&&e.children(a).length>0){i.warn("Cluster without external connections, without a parent and with children",a,r);let d=e.graph().rankdir==="TB"?"LR":"TB";(s=(g=l.get(a))==null?void 0:g.clusterData)!=null&&s.dir&&(d=l.get(a).clusterData.dir,i.warn("Fixing dir",l.get(a).clusterData.dir,d));const p=new O({multigraph:!0,compound:!0}).setGraph({rankdir:d,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",X(e)),k(a,e,p,a),e.setNode(a,{clusterNode:!0,id:a,clusterData:l.get(a).clusterData,label:l.get(a).label,graph:p}),i.warn("New graph after copy node: (",a,")",X(p)),i.debug("Old graph after copy",X(e))}else i.warn("Cluster ** ",a," **not meeting the criteria !externalConnections:",!l.get(a).externalConnections," no parent: ",!e.parent(a)," children ",e.children(a)&&e.children(a).length>0,e.children("D"),r),i.debug(l);n=e.nodes(),i.warn("New list of nodes",n);for(const a of n){const d=e.node(a);i.warn(" Now next level",a,d),d!=null&&d.clusterNode&&B(d.graph,r+1)}},"extractor"),J=m((e,r)=>{if(r.length===0)return[];let n=Object.assign([],r);return r.forEach(o=>{const g=e.children(o),s=J(e,g);n=[...n,...s]}),n},"sorter"),ee=m(e=>J(e,e.children()),"sortNodesByHierarchy"),A=m(async(e,r,n,o,g,s)=>{i.warn("Graph in recursive render:XAX",X(r),g);const a=r.graph().rankdir;i.trace("Dir in recursive render - dir:",a);const d=e.insert("g").attr("class","root");r.nodes()?i.info("Recursive render XXX",r.nodes()):i.info("No nodes found for",r),r.edges().length>0&&i.info("Recursive edges",r.edge(r.edges()[0]));const p=d.insert("g").attr("class","clusters"),E=d.insert("g").attr("class","edgePaths"),b=d.insert("g").attr("class","edgeLabels"),h=d.insert("g").attr("class","nodes");await Promise.all(r.nodes().map(async function(c){const t=r.node(c);if(g!==void 0){const f=JSON.parse(JSON.stringify(g.clusterData));i.trace("Setting data for parent cluster XXX\n Node.id = ",c,"\n data=",f.height,"\nParent cluster",g.height),r.setNode(g.id,f),r.parent(c)||(i.trace("Setting parent",c,g.id),r.setParent(c,g.id,f))}if(i.info("(Insert) Node XXX"+c+": "+JSON.stringify(r.node(c))),t==null?void 0:t.clusterNode){i.info("Cluster identified XBX",c,t.width,r.node(c));const{ranksep:f,nodesep:w}=r.graph();t.graph.setGraph({...t.graph.graph(),ranksep:f+25,nodesep:w});const y=await A(h,t.graph,n,o,r.node(c),s),C=y.elem;Y(t,C),t.diff=y.diff||0,i.info("New compound node after recursive render XAX",c,"width",t.width,"height",t.height),j(C,t)}else r.children(c).length>0?(i.trace("Cluster - the non recursive path XBX",c,t.id,t,t.width,"Graph:",r),i.trace(x(t.id,r)),l.set(t.id,{id:x(t.id,r),node:t})):(i.trace("Node - the non recursive path XAX",c,h,r.node(c),a),await H(h,r.node(c),{config:s,dir:a}))})),await m(async()=>{const c=r.edges().map(async function(t){const f=r.edge(t.v,t.w,t.name);i.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.info("Edge "+t.v+" -> "+t.w+": ",t," ",JSON.stringify(r.edge(t))),i.info("Fix",l,"ids:",t.v,t.w,"Translating: ",l.get(t.v),l.get(t.w)),await Q(b,f)});await Promise.all(c)},"processEdges")(),i.info("Graph before layout:",JSON.stringify(X(r))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),U(r),i.info("Graph after layout:",JSON.stringify(X(r)));let u=0,{subGraphTitleTotalMargin:v}=q(s);return await Promise.all(ee(r).map(async function(c){var f;const t=r.node(c);if(i.info("Position XBX => "+c+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),t==null?void 0:t.clusterNode)t.y+=v,i.info("A tainted cluster node XBX1",c,t.id,t.width,t.height,t.x,t.y,r.parent(c)),l.get(t.id).node=t,I(t);else if(r.children(c).length>0){i.info("A pure cluster node XBX1",c,t.id,t.x,t.y,t.width,t.height,r.parent(c)),t.height+=v,r.node(t.parentId);const w=(t==null?void 0:t.padding)/2||0,y=((f=t==null?void 0:t.labelBBox)==null?void 0:f.height)||0,C=y-w||0;i.debug("OffsetY",C,"labelHeight",y,"halfPadding",w),await z(p,t),l.get(t.id).node=t}else{const w=r.node(t.parentId);t.y+=v/2,i.info("A regular node XBX1 - using the padding",t.id,"parent",t.parentId,t.width,t.height,t.x,t.y,"offsetY",t.offsetY,"parent",w,w==null?void 0:w.offsetY,t),I(t)}})),r.edges().forEach(function(c){const t=r.edge(c);i.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(t),t),t.points.forEach(C=>C.y+=v/2);const f=r.node(c.v);var w=r.node(c.w);const y=_(E,t,l,n,f,w,o);K(t,y)}),r.nodes().forEach(function(c){const t=r.node(c);i.info(c,t.type,t.diff),t.isGroup&&(u=t.diff)}),i.warn("Returning from recursive render XAX",d,u),{elem:d,diff:u}},"recursiveRender"),pe=m(async(e,r)=>{var s,a,d,p,E,b;const n=new O({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((s=e.config)==null?void 0:s.nodeSpacing)||((d=(a=e.config)==null?void 0:a.flowchart)==null?void 0:d.nodeSpacing)||e.nodeSpacing,ranksep:((p=e.config)==null?void 0:p.rankSpacing)||((b=(E=e.config)==null?void 0:E.flowchart)==null?void 0:b.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),o=r.select("g");R(o,e.markers,e.type,e.diagramId),T(),F(),L(),V(),e.nodes.forEach(h=>{n.setNode(h.id,{...h}),h.parentId&&n.setParent(h.id,h.parentId)}),i.debug("Edges:",e.edges),e.edges.forEach(h=>{if(h.start===h.end){const u=h.start,v=u+"---"+u+"---1",c=u+"---"+u+"---2",t=n.node(u);n.setNode(v,{domId:v,id:v,parentId:t.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(v,t.parentId),n.setNode(c,{domId:c,id:c,parentId:t.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(c,t.parentId);const f=structuredClone(h),w=structuredClone(h),y=structuredClone(h);f.label="",f.arrowTypeEnd="none",f.id=u+"-cyclic-special-1",w.arrowTypeEnd="none",w.id=u+"-cyclic-special-mid",y.label="",t.isGroup&&(f.fromCluster=u,y.toCluster=u),y.id=u+"-cyclic-special-2",n.setEdge(u,v,f,u+"-cyclic-special-0"),n.setEdge(v,c,w,u+"-cyclic-special-1"),n.setEdge(c,u,y,u+"-cyc<lic-special-2")}else n.setEdge(h.start,h.end,{...h},h.id)}),i.warn("Graph at first:",JSON.stringify(X(n))),$(n),i.warn("Graph after XAX:",JSON.stringify(X(n)));const g=M();await A(o,n,e.type,e.diagramId,void 0,g)},"render");export{pe as render};
